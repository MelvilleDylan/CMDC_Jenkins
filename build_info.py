# -*- coding: utf-8 -*-
"""
Created on Mon Jul 15 09:14:33 2019

@author: dylan.melville
"""
#import jenkins
#import lxml
import requests
import pandas
import os
import tkinter
import tkinter.filedialog
import datetime


def load_job_details():
    # Gets the data from recent jobs API pull
    TODAY = datetime.date.today()
    file_name = '\logs\Jenkins_jobs_' + str(TODAY) + '.csv'
    file_path = file_name if os.path.isfile(os.getcwd() + file_name) else input_file()
    
    job_details = pandas.read_csv(os.getcwd() + file_path)
    
    return job_details

def make_job_dict(jobs_dataframe):
    #Makes a dictionary for the jobs from a pandas Datrframe
    #Input: Dataframe of the jenkins API output as generated by jenkins_pull.py
    #Output: Dictionary with keys as the names of the jobs and values as dictionaries.
    # The inner dictionaries have keys as the dataframe properties.
    job_names = jobs_dataframe['name']
    jobs_dict = dict()
    for build_index in range(len(jobs_dataframe)):
        jobs_dict[jobs_dataframe['name'][build_index]] = dict([(key,jobs_dataframe[key][build_index]) for key in jobs_dataframe])

    
    return jobs_dict

def generate_jobs_from_dataframe(jobs_dataframe):
    #Takes a dataframe containing job details, and outputs a 
    # dictionary of (key) job names and (value) Job objects.
    #Input: Dictionary, which has job names as the key and dictionaries with
    # all the job details from the csv file as values
    #Output: Dictionary which has job names as the key and Job objects as the
    # values
    jobs_list = [(jobs_dataframe.iloc[iloc_index]['name'],build_job_from_df_entry(jobs_dataframe.iloc[iloc_index])) for iloc_index in range(len(jobs_dataframe.iloc))]
    jobs_dict = dict(jobs_list)
    return jobs_dict

def build_job_from_df_entry(df_entry):
    job = Job(df_entry['url'],df_entry['buildsCount'],df_entry['name'],df_entry['lastCompletedBuildNum'],df_entry['lastSuccessfulBuildNum'],df_entry['lastStableBuildNum'],df_entry['lastFailedBuildNum'],df_entry['lastUnsuccessfulBuildNum'],df_entry['healthReportDescription'],df_entry['healthReportScore'])
    return job
    
def input_file():
    #Gets the csv file with all the up to date Jenkins Job details
    #Input: None
    #Output: String with the selected file_path
    root = tkinter.Tk()
    root.withdraw()
    
    file_path = tkinter.filedialog.askopenfilename()
    return file_path

if __name__ == '__main__':
    print('IN MAIN')
    print(import_job_details())
    print('DONE')
    
class Build:
    def __init__(self, job, number):
        self.number = number
        self.url = job.url+'/'+str(number)
        self.log_url = self.url+'/consoleFull'
        self.full_log = self.scrape_log()
        
    def scrape_log(self):
        #Scrapes the self.log_url web address to get the build's full console
        # output
        #Input: None
        #Output: String containing full log output
        full_html = requests.get(self.log_url)
        return
    
    def scrape_details():
        #Takes the important details from the full console output
        #Input: None
        #Output: Dictionary containing the following keys:
        #   site_code, site_name, clinic_key, start_time, end_time, device_name,
        #   rogers_rssi, rogers_rspr, rogers_rsqr, rogers_imei, rogers_imsi,
        #   telus_rssi, telus_rspr, telus_rsqr, telus_imei, telus_imsi,
        #   thresh_lat, thresh_down, thresh_up, tput_lat, tput_down, tput_up,
        #   longitude, latitude, eProg_ping, AMSR_ping,donor_con_ping,
        #   connect_ping
        
        return
        

class Job:
    def __init__(self, url, number, name, last_complete, last_successful, last_stable, last_failed, last_unsuccessful, health_report_desc, health_report_score):
        self.name = name
        self.url = url
        self.build_count = int(number)
        self.health_report = {'Description':health_report_desc,'Score':health_report_score}
        #self.builds = self.generate_builds()
        self.builds = self.FAKE_TEMPORARY_GENERATE_BUILDS()
        self.key_build_nums = {'Successful':last_successful, 'Stable':last_stable,'Unsuccessful':last_unsuccessful,'Failed':last_failed,'Complete':last_complete}
        self.key_build_objs = dict()

    def generate_builds(self):
        builds = [Build(self, num) for num in range(1,self.build_count+1)]
        builds.insert(0, self.build_count)
        return builds
    
    def key_build_obj(self):
        #Since the constructor only gets the numbers for each of the key builds
        # this function takes that dictionary and generates a new dictionary
        # which has the same keys, but the values are the build objects the
        # numbers are referencing
        keys = self.key_build_nums.keys
        key_nums = [self.key_build_nums[index] for index in keys]
        build_objects = [self.builds[index] for index in key_nums]
        tuples_list = zip(keys,build_objects)
        return dict(tuples_list)
    
    def FAKE_TEMPORARY_GENERATE_BUILDS(self):
        return
        
        
        